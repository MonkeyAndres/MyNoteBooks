---
layout: index
title: Java
categories: Development
---

# CUADERNO DE JAVA
Lenguaje de programacion de proposito general completamente orientado a objetos. Tiene dos manera de trabajo con el mismo:

* JSE (Java Standart Edition) incluye el lenguaje de programacion, el runtime y un conjunto de herramientas de desarrollo.
* JEE (Java Enterprise Edition) biblioteca orientada al desarrollo de aplicaciones empresariales.
  <br><br>

**INDICE**<br>
1. Introduccion al lenguaje JAVA<br>
2. POO<br>
3. Acceso a bases de datos (JDBC)<br>
4. Disenio de aplicaciones JAVA (1/2)<br>
5. Interfaces graficas (GUI)<br>
6. Multithreading (hilos)<br>
7. Networking<br>
8. Disenio de aplicaciones JAVA (2/2)<br>
9. Estructuras de datos dinamicas<br>
10. Parametrizacion mediante XML<br>
11. Introspeccion de clases y objetos<br>
12. Generalizaciones y desarrollo de frameworks<br>
13. Entrada/Salida<br>
14. Consideraciones finales<br>
15. ORM y persistencia de datos<br>
16. Inversion de control por inyeccion de dependencias<br>
17. Actualizacion a Java 8<br>

<br>

## 1 - Introduccion al lenguaje JAVA
Un hola mundo en java se veria de la siguiente manera:
```java
 package libro.cap1;

 public class HolaMundo{
	 public static void Main(String[] args){
		 system.out.printIn("Hola Mundo!");
	 }
 }
```
Ahora vamos a probar a leer datos por teclado.
```java
 package libro.cap1;

 import java.util.Scanner; //Import clase

 public class HolaMundo{
	 public static void Main(String[] args){
		//Esta clase permite leer datos por teclado
		Scanner scanner = new Scanner(System.in);
		System.out.print("Introduce su nombre >> ");

		//Leemos valor
		String nombre = scanner.nextLine();
		System.out.println("Te llamas: " + nombre);
	 }
 }
```
> Dato: println agrega un salto de linea al final y print normal no

#### Declaracion de variables
Se hace como en C++, se indica el tipo y luego el identificador. Para leer por teclado se usa `scanner.nextInt()` se varia int por el tipo de dato y con string se omite. <br>
> Admite datos String y boolean.

#### Estructuras condicionales
En JAVA existen tres tipos de condicionales:
* Condicional simple: if
* Condicional compuesto: switch
* Condicional in-line: `(a>b) ? "Caso verdadero": "Caso falso";`

#### Estructuras repetitivas
Son exactamente las mismas de en C++, while, do-while y for.

#### Definicion de contantes
Las constantes se definen como metodos de una clase con el modificador "final".
> Se recomienda definir constantes siempre en mayusculas.

```java
package libro.cap1;

public class constantes {

  public static final String NOMBRE = "Andres"; //Constante

  public static void main(String[] args){
    //Codigo
  }
}
```
#### Arrays
Los arrays son como en C++, son estaticos, es decir, una vez declarado el numero de elementos este no se puede aumentar y tienen tipo unico.<br>
Declaracion: `int miArray[] = new int[10];` <br>
Si se conocen los elementos que tiene se puede definir asi: `int miArray[] = {1,2}`<br>
> miArray.length devuelve el numero de datos de el array

#### Matrices
Son como los arrays bidimensionales de C++, se definen primero las filas y luego las columnas. <br>
Sintaxis: `int miMatriz [] [] = new int [f] [c];`

#### Tratamiento de Strings
Aqui aprenderemos mas a detalle el manejo de Strings.
* Acceso a un caracter de la cadena = `String.charAt(int posicion);`
* Busca si una cadena contine el caracter desde inicio = `String.indexOf("");`
* Busca si una cadena contine el caracter desde fin = `String.lastIndexOf("");`
* Obten porciones de una cadena = `String.substring(int inicio, int fin);`
* Verificar el inicio de una cadena = `String.startWith("");`
* Verificar el final de una cadena = `String.endWith("");`
* Concatenar cadenas:
  * Con el operador +
  * Con StringBuffer. Instancio una variable `StringBuffer sb = new StringBuffer();` y aniado datos con `.append()` al final se debe pasar el objeto a cadena con `.toString()`
* Conversiones:
  * `Integer.toString(int);`
  * `Integer.parseInt(String);`
  * `Float.toString(float);`
  * `Float.parseFloat(String);`
* Particionar Strings:
  * Dividir sin expresiones regulares. Devuelve un array. = `String.split("");`
  * Con expresiones regulares se usa StringTokenizer. Se define la variable `StringTokenizer st = new StringTokenizer(String, "");`
* Comparar cadenas = `String.equals(String);`

#### La maquina virtual y JDK
Los programas en JAVA se ejecutan sobre una maquina virtual normalmente llamada JVM (Java Virtual Machine) o JRE (Java Runtime Enviroment). Estos dos permiten ejecutar aplicaciones JAVA. <br><br>

Si ademas de ejecutarlas como usuario queremos compilarlas y realizar tareas de desarrollo vamos a nacesitar el paquete JDK (Java Development Kit).

## 2 - POO
Java es un lenguaje fuertemente tipado, esto quiere decir que a todo recurso que se vaya a usar se le tiene que definir un tipo. <br>

En POO tenemos unos conceptos clave:
* Objetos = son variables cuyo tipo de dato es una clase
* Clase = estructura que agrupa datos y la manera de trabajar con ellos
* Atributos = son la variables dentro de la clase, suelen ser private
* Metodos = son las funciones que permiten trabajar estos datos

Se recomienda como buena practica de Java definir "getters" y "setters" para los atributos a los que queramos que el usuario tenga acceso.

#### Metodo "toString()"
Este es un metodo de Java que se auto invoca al meter una clase en una salida por consola. El metodo se puede sobreescribir gracias a que Java lo soporta. Es util para elegir la manera en que se visualizan los datos.

#### Metodo "equals()"
Es un metodo que permite elegir la manera en la que se coparan dos elementos de la misma clase.

#### Definicion y creacion de objetos
Ejemplo de una clase y una definicion de objeto:
```java
import java.util.Scanner;

public class PC{
  //Atributos
  private int memoriaRAM;
  private int memoriaROM;

  //Constructor
  public PC(int ram, int rom){
    memoriaRAM = ram;
    memoriaROM = rom;
  }

  //Getters
  public int getRAM(){return memoriaRAM;}
  public int getROM(){return memoriaROM;}

  //Setters
  public void setRAM(int ram){memoriaRAM = ram;}
  public void setROM(int rom){memoriaROM = rom;}

  public String toString(){
  	return "RAM = "+memoriaRAM+" ROM = "+memoriaROM;
  }
  public boolean equals(Object o){
    PC obj = (PC)o; //Declaro un objeto tipo PC
    return (memoriaRAM >= obj.memoriaRAM) && (memoriaROM >= obj.memoriaROM);
  }
}
```
> Java tiene soporte para sobrecarga, es decir se pueden definir varios metodos de mismo nombre pero variando argumentos.
> Los atributos o metodos "static" son comunes a todas las instancias de la clase

#### Encapsulamiento
Los metodos y atributos en Java pueden ser de cuatro tipos:
* Se pueden ver dentro de clases heredadas y fuera de clase = `public`
* Esta encapsulado y solo se tiene acceso mediante esa clase = `privado`
* Solo visible por la cadena de herencia = `protected`
* Visible para las clases del mismo paquete = `friendly`
> El tipo friendly no se define, simplemente al no tener ninguno de los anteriores se declara como friendly

#### Packages
Los paquetes en Java son una manera de organizar las clases de Java, esto se hace mediante carpetas. <br>
Ejemplo el paquete "java.cap2.fecha" esta hubicado en una carpeta llamada "cap2" y luego la carpeta ''fecha''.

#### APIs
Es el conjunto de paquetes (clases y metodos) que tenemos disponibles para crear una aplicacion, estos paquetes se compilan en el formato ".jar"

#### JavaDoc
Es una utilidad incluida en eclipse que permite documentar un proyecto en java generando de manera automatica archivos HTML. Investigar mas adelante.

#### Incluir clases de otros paquetes
Para esto hacemos uno del comando `import` mas la ruta hacia el paquete donde se encuentra la clase que queremos importar.

#### Herencia
En java todas las clases heredan de la clase padre Object pero aparte de esto podemos definir clases padre e hijo de la siguiente forma:
```java
public class ClaseHijo extends ClasePadre{
  //Codigo de la clase hijo
  
  public ClaseHijo(String a){ //Argumentos que necesita contruct padre
    super(a); //Pasamos los argumentos al constructor padre
  }
}
```
> Java no tiene herencia multiple

En la herencia en Java existen dos palabras importantes:
* **super** = hace referencia a la clase padre, es decir, `super.saluda()` invoca el metodo saluda de la clase padre.
* **this** = hace referencia otros metodos y atributos de la misma clase.

#### Polimorfismo
Pendiente de investigacion.

#### Clase abstracta
Son clases con metodos que no pueden ser definidos por falta de informacion. Es algo asi como crear un esqueleto de atributos y metodos pero sin definirlos.
```java
public abstract class FigurasGeometricas(){
  public abstract double area(); //No se define
  
  public String toString(){
    return "El area es = "+area(); //Esto es posible
  }
}

// -Otro Archivo-

public class Rectangulo extends FigurasGeometricas(){
  private int base;
  private int altura;
  
  public Rectangulo (int b, int h){
    this.base = b;
    this.altura = h;
  }
  
  //Defino aqui el metodo abstracto
  public double area(){
    return base * altura;
  }
}
```
Las clases abstractas necesitan ser heredadas por otras para ser instanciadas, es decir, no puedo instanciar la clase "FigurasGeometricas" pero si puedo instanciar la clase "Rectangulo".

#### El metodo "finalize"
Es identico al destructor de clases que tiene C++
```java
public void finalize(){
  //Codigo
}
```
#### Clases Utilitarias
Tipo de clases con metodos estaticos. <br>
Los metodos estaticos son todos aquellos que se pueden invocar sin la necesidad de crear un objeto de la clase.
```java
public class Operaciones(){
  public static int suma(int a, int b){
    return a + b;
  }
}

Operaciones.suma(4,9);
```
#### Clases genericas
Son clases que agrupan objetos y se les puede definir el tipo de objeto con el que van a trabajar. Esto se puede usar en parametros de argumentos y en tipos de metodos.
```java
//Ejemplo tenermos una clase que agrupa elementos
public class miColeccion<T>{ 
  //Codigo
}

//Instancio la clase
miColeccion<String> coleccionCadenas = new miColeccion<String>
```
Las clases genericas se usan con dos estructuras de datos:
* **PIlas**: agrupan elementos uno sobre otro y el ultimo es el que se obtiene al desapilar.
* **Colas**: se agrupan uno al final de otro y al eliminar se quitan elementos del principio.

> Tienes que desarrollarlos, no existe un estandar.

#### Interfaces
Son una especie de clases que sirven para implementar en otras clases. Son la solucion ante la falta de herencia multiple en java.
```java
public interface Idioma{
  public void saludo();
}

public class Ingles implements Idioma{
  public void saludo(){
    System.out.println("Hello! :D");
  }
}
```

> El programa anterior define que todos los idiomas tienen una manera de saludar pero no la define, mas tarde el idioma ingles IMPLEMENTA esta interface y define como se saluda en ingles.

#### Metodo COMPARABLE
Para entender este metodo y las interfaces vamos a hacer un sistema que ordene alumnos por su nombre.

```java
/*
Interfaz Comparable
Este programa define una interfaz generica que tiene un metodo no definido que compara dos objetos tipo T.
*/
public interface Comparable<T>{
  public int compareTo(T objeto);
}
```
```java
/*
Clase Alumno
Esta clase implementa la interfaz Comparable y define el tipo de objeto a tratar. Despues sobreescribe el metodo "compareTo" y hace que devuelva 1 si el primer elemento resulta ganador y dos en caso de que sea al reves.
*/
public class Alumno implements Comparable<Alumno> {
  public String nombre;
  private int notaMedia;

  public Alumno(String n, int nm){
    this.nombre = n;
    this.notaMedia = nm;
  }

  public String getNombre(){
    return this.nombre;
  }

  public int compareTo(Alumno objeto){
    if(this.nombre.charAt(0) <= objeto.getNombre().charAt(0)){
      return 1;
    } else {
      return 2;
    }
  }
}
```

```java
/*
Clase Util
Esta clase contiene el metodo estatico ordenar, este mediante el algoritmo de burbuja permite ordenar un array de objetos con la interface Comparable.
*/
public class Util {
	public static void ordenar (Comparable arr[]){
		boolean ordenado = false; 
		while(!ordenado){
			ordenado = true;
			for(int i = 0; i<arr.length-1; i++){
				if (arr[i+1].compareTo(arr[i]) == 1) {
					Comparable aux = arr[i];
					arr[i] = arr[i+1];
					arr[i+1] = aux;
					ordenado = false;
				}
			}
		}
	}
}
```
> Este algoritmo compara pares de elementos y los intercambia poco a poco. (Buscar en google "algoritmo de la burbuja para un mejor entendimiento")

```java
/*
Clase Main
Crea un array de 3 alumnos y ordena sus nombres
*/
public class Main {
	public static void main(String[] args){
		Alumno arr[] = {
			new Alumno("Juan", 7),
			new Alumno("Pedro", 3),
			new Alumno("Andres", 7),
		};
		
		Util.ordenar(arr);
		for(int i = 0; i < arr.length; i++){
			System.out.println(arr[i].getNombre());
		}
	}
}
```

#### Colecciones
Llamamos coleccion a un grupo de datos determinado, por ejemplo un String[ ] es un grupo de String. <br>
Para agrupar elementos Java provee la interface Collection. Las clases ArrayList y Vector implementan esta interface.

```java
import java.Util.Vector;

public class TestVector{
  public static void main(String[] args){
    Vector<String> VNombres = new Vector<String>();
    
    VNombres.add("Andres");
    VNombres.add("Pedro");
    VNombres.add("Maria");
    
    String aux;
    
    for(int i = 0; i<VNombres.size(); i++){
      aux = VNombres.get(i);
      System.out.println(aux);
    }
  }
}
```
> No hay que confundir un Array con un Vector, el Array esta definido por defecto por el lenguaje de programacion pero el Vector es algo programable.

#### Excepciones
Es la manera de manejar los fallos que ocurren mientras la ejecucion del programa.
```java
try{
  //Codigo que puede dar un error
} catch (/*Excepcion especifica sino "Exception e"*/){
  //Codigo si ocurre este error
} catch (){
  //Codigo para otro error.
} finally{
  //Codigo que se ejecuta al final independientente de si falla.
}
```